# PropDocs iOS Client - Core Data Models

## Overview

Core Data serves as the local caching and offline storage layer for the PropDocs iOS client. These models mirror the API data structures and provide offline-first functionality with smart synchronization to the backend API.

## Entity Relationship Diagram (Client-Side Cache)

```
User (Cached from API)
├── properties (1-to-many) → Property
├── userID: String (API ID)
├── email: String
├── subscriptionTier: String
├── lastSyncDate: Date
└── syncStatus: String

Property (Cached from API)
├── owner (many-to-1) → User
├── assets (1-to-many) → Asset
├── reports (1-to-many) → PropertyReport
├── propertyID: String (API ID)
├── address: String
├── squareFootage: Int32
├── yearBuilt: Int32
├── lastSyncDate: Date
├── syncStatus: String
└── needsUpload: Bool

Asset (Cached from API)
├── property (many-to-1) → Property
├── maintenanceSchedules (1-to-many) → MaintenanceSchedule
├── serviceRecords (1-to-many) → ServiceRecord
├── photos (1-to-many) → AssetPhoto
├── assetID: String (API ID)
├── category: String
├── type: String
├── make: String?
├── model: String?
├── serialNumber: String?
├── installationDate: Date?
├── purchaseCost: Decimal?
├── warrantyExpiration: Date?
├── condition: String
├── location: String
├── healthScore: Float (calculated by API)
├── lastSyncDate: Date
├── syncStatus: String
├── needsUpload: Bool
└── isAIProcessed: Bool

MaintenanceSchedule (Generated by API)
├── asset (many-to-1) → Asset
├── tasks (1-to-many) → MaintenanceTask
├── scheduleID: String (API ID)
├── frequency: String
├── description: String
├── nextDueDate: Date
├── isActive: Bool
├── isAIGenerated: Bool
├── lastSyncDate: Date
├── syncStatus: String
└── needsUpload: Bool

MaintenanceTask (Managed locally + synced to API)
├── schedule (many-to-1) → MaintenanceSchedule
├── serviceRecord (1-to-1) → ServiceRecord?
├── taskID: String (API ID)
├── title: String
├── description: String
├── dueDate: Date
├── completedDate: Date?
├── status: String
├── priority: String
├── localNotificationID: String?
├── lastSyncDate: Date
├── syncStatus: String
└── needsUpload: Bool

ServiceRecord
├── asset (many-to-1) → Asset
├── task (1-to-1) → MaintenanceTask?
├── serviceProvider (many-to-1) → ServiceProvider?
├── photos (1-to-many) → ServicePhoto
├── serviceDate: Date
├── cost: Decimal?
├── notes: String?
├── serviceType: String
└── createdAt: Date

ServiceProvider
├── serviceRecords (1-to-many) → ServiceRecord
├── name: String
├── contactInfo: String?
├── rating: Float?
└── specialties: [String]

PropertyReport
├── property (many-to-1) → Property
├── shareLinks (1-to-many) → ShareLink
├── title: String
├── generatedAt: Date
├── expiresAt: Date?
├── isPublic: Bool
└── reportData: Data

ShareLink
├── report (many-to-1) → PropertyReport
├── linkID: String (unique)
├── accessLogs (1-to-many) → AccessLog
├── expiresAt: Date?
├── isActive: Bool
└── createdAt: Date

AccessLog
├── shareLink (many-to-1) → ShareLink
├── accessedAt: Date
├── ipAddress: String?
└── userAgent: String?

AssetPhoto (Local storage + API sync)
├── asset (many-to-1) → Asset
├── photoID: String (API ID)
├── localImageData: Data? (for offline viewing)
├── remoteImageURL: String? (from API)
├── thumbnailData: Data? (cached thumbnail)
├── caption: String?
├── isPrimary: Bool
├── uploadStatus: String
├── lastSyncDate: Date
└── needsUpload: Bool

ServicePhoto (Local storage + API sync)
├── serviceRecord (many-to-1) → ServiceRecord
├── photoID: String (API ID)
├── localImageData: Data? (for offline viewing)
├── remoteImageURL: String? (from API)
├── thumbnailData: Data? (cached thumbnail)
├── caption: String?
├── uploadStatus: String
├── lastSyncDate: Date
└── needsUpload: Bool

LocalNotification (iOS-specific, not synced to API)
├── relatedTask (many-to-1) → MaintenanceTask?
├── notificationID: String (iOS notification identifier)
├── title: String
├── body: String
├── scheduledFor: Date
├── isScheduled: Bool
├── isDelivered: Bool
└── notificationType: String

SyncQueue (Tracks pending API operations)
├── entityType: String (Asset, Task, etc.)
├── entityID: String
├── operation: String (create, update, delete)
├── jsonData: Data (serialized entity data)
├── createdAt: Date
├── retryCount: Int32
└── lastAttempt: Date?
```

## Core Data Model Definitions (Client-Side Cache)

### User Entity (Cached from API)
```swift
@objc(User)
public class User: NSManagedObject {
    @NSManaged public var userID: String // API identifier
    @NSManaged public var email: String
    @NSManaged public var displayName: String?
    @NSManaged public var subscriptionTier: String // "free", "premium", "professional"
    @NSManaged public var notificationPreferences: Data? // JSON encoded preferences
    @NSManaged public var lastSyncDate: Date
    @NSManaged public var syncStatus: String // "synced", "pending", "error"
    
    // Relationships
    @NSManaged public var properties: NSSet?
    @NSManaged public var localNotifications: NSSet?
}
```

### Property Entity (Cached from API)
```swift
@objc(Property)
public class Property: NSManagedObject {
    @NSManaged public var propertyID: String // API identifier
    @NSManaged public var address: String
    @NSManaged public var city: String
    @NSManaged public var state: String
    @NSManaged public var zipCode: String
    @NSManaged public var squareFootage: Int32
    @NSManaged public var yearBuilt: Int32
    @NSManaged public var propertyType: String // "single_family", "condo", "townhouse"
    @NSManaged public var nickname: String?
    @NSManaged public var healthScore: Float // Calculated by API
    @NSManaged public var lastSyncDate: Date
    @NSManaged public var syncStatus: String // "synced", "pending", "error"
    @NSManaged public var needsUpload: Bool // True if locally modified
    
    // Relationships
    @NSManaged public var owner: User
    @NSManaged public var assets: NSSet?
    @NSManaged public var reports: NSSet?
}
```

### Asset Entity
```swift
@objc(Asset)
public class Asset: NSManagedObject {
    @NSManaged public var assetID: String
    @NSManaged public var category: String // "HVAC", "Plumbing", "Electrical", "Appliance"
    @NSManaged public var type: String // "Water Heater", "Air Conditioner", "Dishwasher"
    @NSManaged public var make: String?
    @NSManaged public var model: String?
    @NSManaged public var serialNumber: String?
    @NSManaged public var location: String // "Kitchen", "Basement", "Attic"
    @NSManaged public var installationDate: Date?
    @NSManaged public var purchaseCost: NSDecimalNumber?
    @NSManaged public var warrantyExpiration: Date?
    @NSManaged public var condition: String // "excellent", "good", "fair", "poor"
    @NSManaged public var healthScore: Float // 0.0 - 1.0
    @NSManaged public var aiIdentified: Bool
    @NSManaged public var notes: String?
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    
    // Relationships
    @NSManaged public var property: Property
    @NSManaged public var photos: NSSet?
    @NSManaged public var maintenanceSchedules: NSSet?
    @NSManaged public var serviceRecords: NSSet?
}
```

### MaintenanceSchedule Entity
```swift
@objc(MaintenanceSchedule)
public class MaintenanceSchedule: NSManagedObject {
    @NSManaged public var scheduleID: String
    @NSManaged public var title: String
    @NSManaged public var description: String
    @NSManaged public var frequency: String // "monthly", "quarterly", "annually", "custom"
    @NSManaged public var intervalDays: Int32 // For custom frequency
    @NSManaged public var nextDueDate: Date
    @NSManaged public var isActive: Bool
    @NSManaged public var isAIGenerated: Bool
    @NSManaged public var priority: String // "low", "medium", "high", "critical"
    @NSManaged public var estimatedCost: NSDecimalNumber?
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    
    // Relationships
    @NSManaged public var asset: Asset
    @NSManaged public var tasks: NSSet?
}
```

### MaintenanceTask Entity
```swift
@objc(MaintenanceTask)
public class MaintenanceTask: NSManagedObject {
    @NSManaged public var taskID: String
    @NSManaged public var title: String
    @NSManaged public var description: String?
    @NSManaged public var dueDate: Date
    @NSManaged public var completedDate: Date?
    @NSManaged public var status: String // "pending", "overdue", "completed", "skipped"
    @NSManaged public var priority: String // "low", "medium", "high", "critical"
    @NSManaged public var estimatedDuration: Int32 // in minutes
    @NSManaged public var actualCost: NSDecimalNumber?
    @NSManaged public var notes: String?
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    
    // Relationships
    @NSManaged public var schedule: MaintenanceSchedule
    @NSManaged public var serviceRecord: ServiceRecord?
}
```

### ServiceRecord Entity
```swift
@objc(ServiceRecord)
public class ServiceRecord: NSManagedObject {
    @NSManaged public var recordID: String
    @NSManaged public var serviceDate: Date
    @NSManaged public var serviceType: String // "maintenance", "repair", "replacement", "inspection"
    @NSManaged public var description: String
    @NSManaged public var cost: NSDecimalNumber?
    @NSManaged public var laborCost: NSDecimalNumber?
    @NSManaged public var partsCost: NSDecimalNumber?
    @NSManaged public var notes: String?
    @NSManaged public var warrantyInfo: String?
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    
    // Relationships
    @NSManaged public var asset: Asset
    @NSManaged public var task: MaintenanceTask?
    @NSManaged public var serviceProvider: ServiceProvider?
    @NSManaged public var photos: NSSet?
}
```

### ServiceProvider Entity
```swift
@objc(ServiceProvider)
public class ServiceProvider: NSManagedObject {
    @NSManaged public var providerID: String
    @NSManaged public var name: String
    @NSManaged public var contactName: String?
    @NSManaged public var phoneNumber: String?
    @NSManaged public var email: String?
    @NSManaged public var website: String?
    @NSManaged public var address: String?
    @NSManaged public var rating: Float // 0.0 - 5.0
    @NSManaged public var specialties: Data? // JSON encoded array
    @NSManaged public var notes: String?
    @NSManaged public var isPreferred: Bool
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    
    // Relationships
    @NSManaged public var serviceRecords: NSSet?
}
```

## Client-Side Data Management Considerations

### API Integration Patterns
1. **Cache-First Strategy**: Always read from Core Data, sync with API in background
2. **Optimistic Updates**: Update UI immediately, queue API calls for later
3. **Conflict Resolution**: Handle cases where local and remote data differ
4. **Retry Logic**: Queue failed API operations for retry when network is available

### Sync Status Management
- **"synced"**: Local data matches API data
- **"pending"**: Local changes waiting to be uploaded to API
- **"error"**: API sync failed, needs retry
- **"uploading"**: Currently syncing with API

### Performance Optimizations
1. **Indexes**: API IDs, sync status, lastSyncDate for efficient queries
2. **Batch Sync**: Process multiple API operations in batches
3. **Background Processing**: Use background contexts for sync operations
4. **Image Caching**: Store thumbnails locally, lazy load full images

### Offline-First Architecture
1. **Local Storage**: All data cached locally for offline access
2. **Background Sync**: Periodic sync with API using BGAppRefreshTask
3. **Queue Management**: Track pending operations in SyncQueue entity
4. **Smart Caching**: Intelligent cache invalidation based on sync timestamps

### Data Privacy & Security
1. **API Token Storage**: Secure token storage in iOS Keychain
2. **Local Encryption**: Core Data encryption for sensitive cached data
3. **Photo Privacy**: Local image storage with secure cleanup
4. **User Data Isolation**: Proper data partitioning by authenticated user

## Usage Examples (Client-Side Cache Operations)

### Fetching Cached Assets with Offline Support
```swift
let fetchRequest: NSFetchRequest<Asset> = Asset.fetchRequest()
fetchRequest.predicate = NSPredicate(format: "property == %@", property)
fetchRequest.sortDescriptors = [NSSortDescriptor(key: "category", ascending: true)]

// Always fetch from local cache first
let assets = try context.fetch(fetchRequest)

// Trigger background API sync if needed
if shouldRefreshFromAPI {
    Task {
        await assetRepository.syncWithAPI()
    }
}
```

### Finding Assets That Need API Upload
```swift
let fetchRequest: NSFetchRequest<Asset> = Asset.fetchRequest()
fetchRequest.predicate = NSPredicate(format: "needsUpload == true")

let pendingAssets = try context.fetch(fetchRequest)
// Queue these for API upload
```

### Managing Sync Queue for Offline Operations
```swift
let fetchRequest: NSFetchRequest<SyncQueue> = SyncQueue.fetchRequest()
fetchRequest.predicate = NSPredicate(format: "retryCount < 3")
fetchRequest.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: true)]

let pendingOperations = try context.fetch(fetchRequest)
// Process these when network becomes available
```

### Local Notification Management
```swift
let fetchRequest: NSFetchRequest<LocalNotification> = LocalNotification.fetchRequest()
fetchRequest.predicate = NSPredicate(format: "scheduledFor > %@ AND isScheduled == false", Date())

let unscheduledNotifications = try context.fetch(fetchRequest)
// Schedule these with iOS notification system
```

This client-focused Core Data model provides a robust foundation for offline-first iOS functionality with intelligent API integration, background synchronization, and local notification management.